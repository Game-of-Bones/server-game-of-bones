import { Request, Response, NextFunction } from 'express';
import { validateCreateComment, validateUpdateComment } from '../../middleware/commentValidation';

describe('Comment Validation Middleware', () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: NextFunction;

  beforeEach(() => {
    mockRequest = {
      body: {},
      params: {}
    };

    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis()
    };

    mockNext = jest.fn();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('validateCreateComment', () => {
    it('debe pasar validaci√≥n con datos correctos', () => {
      mockRequest.body = {
        content: 'Este es un comentario v√°lido'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('debe rechazar contenido vac√≠o', () => {
      mockRequest.body = {
        content: ''
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido no puede estar vac√≠o'])
      });
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('debe rechazar contenido solo con espacios', () => {
      mockRequest.body = {
        content: '   '
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido no puede estar vac√≠o'])
      });
    });

    it('debe rechazar contenido sin campo content', () => {
      mockRequest.body = {};

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido es requerido'])
      });
    });

    it('debe rechazar contenido muy largo (m√°s de 1000 caracteres)', () => {
      mockRequest.body = {
        content: 'a'.repeat(1001)
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido no puede exceder los 1000 caracteres'])
      });
    });

    it('debe aceptar contenido en el l√≠mite (1000 caracteres)', () => {
      mockRequest.body = {
        content: 'a'.repeat(1000)
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('debe sanitizar HTML peligroso', () => {
      mockRequest.body = {
        content: '<script>alert("XSS")</script>Comentario'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockRequest.body.content).not.toContain('<script>');
      expect(mockRequest.body.content).toContain('&lt;script&gt;');
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe sanitizar m√∫ltiples etiquetas HTML', () => {
      mockRequest.body = {
        content: '<img src="x" onerror="alert(1)"><div>Test</div>'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockRequest.body.content).not.toContain('<img');
      expect(mockRequest.body.content).not.toContain('<div>');
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe aceptar contenido con caracteres especiales v√°lidos', () => {
      mockRequest.body = {
        content: 'Comentario con √±, √°, √©, √≠, √≥, √∫, ¬ø? y ¬°!'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockRequest.body.content).toContain('√±');
    });

    it('debe rechazar contenido no string', () => {
      mockRequest.body = {
        content: 12345
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido debe ser texto'])
      });
    });

    it('debe limpiar espacios al inicio y final', () => {
      mockRequest.body = {
        content: '   Comentario con espacios   '
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockRequest.body.content).toBe('Comentario con espacios');
      expect(mockNext).toHaveBeenCalledWith();
    });
  });

  describe('validateUpdateComment', () => {
    it('debe pasar validaci√≥n con datos correctos', () => {
      mockRequest.body = {
        content: 'Contenido actualizado v√°lido'
      };

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockResponse.status).not.toHaveBeenCalled();
    });

    it('debe rechazar contenido vac√≠o', () => {
      mockRequest.body = {
        content: ''
      };

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido no puede estar vac√≠o'])
      });
    });

    it('debe rechazar sin campo content', () => {
      mockRequest.body = {};

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.arrayContaining(['El contenido es requerido'])
      });
    });

    it('debe rechazar contenido muy largo', () => {
      mockRequest.body = {
        content: 'a'.repeat(1001)
      };

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
    });

    it('debe sanitizar HTML en actualizaciones', () => {
      mockRequest.body = {
        content: '<script>alert("XSS")</script>Actualizaci√≥n'
      };

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockRequest.body.content).not.toContain('<script>');
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe validar ID del comentario en params', () => {
      mockRequest.params = { id: 'invalid' };
      mockRequest.body = { content: 'Contenido v√°lido' };

      validateUpdateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      // Deber√≠a pasar la validaci√≥n del contenido
      // La validaci√≥n del ID se hace en el controlador
      expect(mockNext).toHaveBeenCalledWith();
    });
  });

  describe('Casos edge', () => {
    it('debe manejar contenido con saltos de l√≠nea', () => {
      mockRequest.body = {
        content: 'L√≠nea 1\nL√≠nea 2\nL√≠nea 3'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockRequest.body.content).toContain('\n');
    });

    it('debe manejar contenido con emojis', () => {
      mockRequest.body = {
        content: 'Gran descubrimiento! ü¶ïü¶¥üëç'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe rechazar contenido con solo emojis si est√° vac√≠o despu√©s de trim', () => {
      mockRequest.body = {
        content: '   '
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
    });

    it('debe manejar contenido con URLs', () => {
      mockRequest.body = {
        content: 'Mira esta fuente: https://example.com/dinosaurios'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockRequest.body.content).toContain('https://example.com');
    });

    it('debe sanitizar intentos de inyecci√≥n SQL en el contenido', () => {
      mockRequest.body = {
        content: "'; DROP TABLE comments; --"
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      // La sanitizaci√≥n no debe afectar el contenido SQL-like
      // ya que se trata como texto plano
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe manejar m√∫ltiples errores de validaci√≥n', () => {
      mockRequest.body = {
        content: '' // Vac√≠o
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
      expect(mockResponse.json).toHaveBeenCalledWith({
        success: false,
        errors: expect.any(Array)
      });
    });

    it('debe preservar contenido v√°lido sin cambios innecesarios', () => {
      const originalContent = 'Este es un comentario normal sobre f√≥siles';
      mockRequest.body = {
        content: originalContent
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockRequest.body.content).toBe(originalContent);
      expect(mockNext).toHaveBeenCalledWith();
    });

    it('debe manejar contenido con comillas', () => {
      mockRequest.body = {
        content: 'El paleont√≥logo dijo: "Incre√≠ble hallazgo"'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
      expect(mockRequest.body.content).toContain('"');
    });

    it('debe rechazar objetos anidados en content', () => {
      mockRequest.body = {
        content: { nested: 'object' }
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
    });

    it('debe rechazar arrays en content', () => {
      mockRequest.body = {
        content: ['array', 'content']
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockResponse.status).toHaveBeenCalledWith(400);
    });

    it('debe manejar contenido con tabulaciones', () => {
      mockRequest.body = {
        content: 'Contenido\tcon\ttabulaciones'
      };

      validateCreateComment(
        mockRequest as Request,
        mockResponse as Response,
        mockNext
      );

      expect(mockNext).toHaveBeenCalledWith();
    });
  });
});